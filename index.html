<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FIT1045 - C++ 可视化执行模拟器 (完整版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto Sans SC', sans-serif; background-color: #f0f2f5; }
        .font-mono { font-family: 'Roboto Mono', monospace; }
        .panel { background-color: #ffffff; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); padding: 1.5rem; }
        .code-line { padding: 0.25rem 0.75rem; border-radius: 4px; transition: background-color 0.3s; white-space: pre; }
        .code-line.active { background-color: #dbeafe; font-weight: 500; }
        .state-panel h3 { border-bottom: 2px solid #e5e7eb; padding-bottom: 0.5rem; margin-bottom: 1rem; font-size: 1.1rem; font-weight: 700; color: #1f2937; }
        .value-changed { animation: flash 0.8s ease; }
        @keyframes flash { 0%, 100% { background-color: transparent; } 50% { background-color: #fef08a; } }
        .btn { padding: 0.5rem 1rem; border-radius: 6px; border: none; cursor: pointer; font-weight: 500; transition: all 0.2s; display: inline-flex; align-items: center; gap: 0.5rem; }
        .btn-primary { background-color: #2563eb; color: white; }
        .btn-primary:hover:not(:disabled) { background-color: #1d4ed8; }
        .btn-secondary { background-color: #e5e7eb; color: #374151; }
        .btn-secondary:hover { background-color: #d1d5db; }
        .btn:disabled { background-color: #d1d5db; cursor: not-allowed; }
        .nav-tabs { display: flex; flex-wrap: wrap; border-bottom: 2px solid #e5e7eb; margin-bottom: 1rem; }
        .tab { padding: 0.75rem 1.25rem; cursor: pointer; border-bottom: 2px solid transparent; margin-bottom: -2px; font-weight: 500; color: #6b7280; text-align: center; }
        .tab.active { color: #2563eb; border-color: #2563eb; }
        .quiz-option { display: block; width: 100%; text-align: left; padding: 0.75rem 1rem; border: 1px solid #d1d5db; border-radius: 6px; margin-bottom: 0.5rem; transition: all 0.2s; }
        .quiz-option:hover:not(:disabled) { border-color: #60a5fa; background-color: #f0f9ff; }
        .quiz-option.correct { background-color: #dcfce7; border-color: #22c55e; color: #15803d; }
        .quiz-option.incorrect { background-color: #fee2e2; border-color: #ef4444; color: #b91c1c; }
    </style>
</head>
<body class="p-4 md:p-8">

    <header class="text-center mb-6">
        <h1 class="text-3xl font-bold text-gray-800">FIT1045 C++ 交互式练习 (完整版)</h1>
        <p class="text-md text-gray-600 mt-1">覆盖全部九道题，结合模拟执行与概念测验</p>
    </header>

    <div class="nav-tabs" id="question-tabs"></div>
    <div id="content-container"></div>

    <script>
    const questions = [
        {
            title: 'Q1: 术语定义',
            type: 'quiz',
            quizQuestions: [
                { question: "哪个术语指的是在函数或代码块内部声明的变量，其作用域仅限于该代码块？", options: ["全局变量", "局部变量", "参数", "结构体"], answer: 1, explanation: "局部变量（Local Variable）的作用域仅限于其声明所在的函数或代码块。" },
                { question: "在所有函数之外声明，程序的任何部分都可以访问的变量称为什么？", options: ["局部变量", "枚举", "全局变量", "数组"], answer: 2, explanation: "全局变量（Global Variable）定义在所有函数之外，因此它的生命周期和作用域是全局的。" },
                { question: "函数定义中用于接收传入值的“占位符”叫什么？", options: ["实参 (Argument)", "返回 (Return)", "参数 (Parameter)", "异常 (Exception)"], answer: 2, explanation: "参数（Parameter）是函数定义的一部分，它声明了函数期望接收的数据的类型和名称。" },
                { question: "调用函数时传递给函数的具体值被称为什么？", options: ["实参 (Argument)", "参数 (Parameter)", "局部变量", "返回值"], answer: 0, explanation: "实参（Argument）是在函数调用时提供的，用来初始化对应参数的具体值。" },
                { question: "一个执行特定任务并返回一个结果的代码块，通常称为什么？", options: ["过程 (Procedure)", "函数 (Function)", "结构体 (Struct)", "循环 (Loop)"], answer: 1, explanation: "函数（Function）封装了一系列操作，并且通常会通过 `return` 语句返回一个计算结果。" },
                { question: "一个执行特定动作但不返回任何值的代码块（在C++中用`void`表示）是什么？", options: ["函数 (Function)", "数组 (Array)", "过程 (Procedure)", "枚举 (Enumeration)"], answer: 2, explanation: "过程（Procedure）是一种特殊的函数，它的返回类型是 `void`，表示它不返回任何值，只执行操作。" },
                { question: "哪个关键字用于从函数中交还一个值并立即结束该函数的执行？", options: ["break", "continue", "goto", "return"], answer: 3, explanation: "`return` 关键字用于结束当前函数的执行，并将一个值（如果函数有返回值类型）返回给调用者。" },
                { question: "当程序运行时发生错误，打断了正常的代码执行流程，这被称为什么？", options: ["编译错误", "语法错误", "逻辑错误", "异常 (Exception)"], answer: 3, explanation: "异常（Exception）是在程序运行时发生的意外事件，它会中断代码的正常流程。" },
                { question: "哪种结构允许你将不同类型的数据（如姓名、ID、分数）打包成一个单一的实体？", options: ["数组 (Array)", "枚举 (Enumeration)", "结构体 (Struct)", "函数 (Function)"], answer: 2, explanation: "结构体（Struct）是创建自定义复合数据类型的工具，非常适合用来表示真实世界的实体。" },
                { question: "为了提高代码可读性，将一组命名的整数常量组合在一起的数据类型是什么？", options: ["数组 (Array)", "结构体 (Struct)", "枚举 (Enumeration)", "常量 (Constant)"], answer: 2, explanation: "枚举（Enumeration）允许我们用有意义的名字（如 RED, GREEN）来代替无意义的数字（如 0, 1），增强代码的可读性和可维护性。" },
                { question: "一个固定大小的、存储相同类型元素的有序集合是什么？", options: ["结构体 (Struct)", "数组 (Array)", "链表 (Linked List)", "集合 (Set)"], answer: 1, explanation: "数组（Array）在内存中是连续存储的，通过索引可以快速访问任何元素，但其大小在创建时就已固定。" }
            ]
        },
        {
            title: 'Q2: 代码执行', type: 'simulator',
            code: [ 'int first[5] = {1,1,3,4,5};', 'int second[3] = {2,2,3};', 'int result[5] = {0,0,0,0,0};', 'int i=0, j=0, k=0;', 'while (i < 5 && j < 3 && k < 5) {', '  if (first[i] <= second[j]) {', '    result[k] = first[i];', '    i++;', '  } else {', '    result[k] = second[j];', '    j++;', '  }', '  k++;', '}', '// 后续循环' ],
            steps: [ { line: 0, vars: {}, mem: { 'first': [1,1,3,4,5] }, exp: '声明并初始化 `first` 数组。' }, { line: 1, vars: {}, mem: { 'second': [2,2,3] }, exp: '声明并初始化 `second` 数组。' }, { line: 2, vars: {}, mem: { 'result': [0,0,0,0,0] }, exp: '声明并初始化 `result` 数组。' }, { line: 3, vars: { i: 0, j: 0, k: 0 }, exp: '声明并初始化循环变量 i, j, k。' }, { line: 4, exp: '进入循环。检查条件: i(0)<5 && j(0)<3 && k(0)<5，结果为真。' }, { line: 5, exp: '进入条件判断。比较 first[0](1) 与 second[0](2)。' }, { line: 6, mem: { result: (s) => { s.mem.result[s.vars.k] = s.mem.first[s.vars.i]; return s.mem.result; } }, exp: '1 <= 2 为真。result[0] 被赋值为 first[0] 的值 1。' }, { line: 7, vars: { i: (s) => s.vars.i + 1 }, exp: 'i 自增为 1。' }, { line: 12, vars: { k: (s) => s.vars.k + 1 }, exp: 'k 自增为 1。' }, { line: 4, exp: '再次循环。检查条件: i(1)<5 && j(0)<3 && k(1)<5，结果为真。' }, { line: 5, exp: '比较 first[1](1) 与 second[0](2)。' }, { line: 6, mem: { result: (s) => { s.mem.result[s.vars.k] = s.mem.first[s.vars.i]; return s.mem.result; } }, exp: '1 <= 2 为真。result[1] 被赋值为 first[1] 的值 1。' }, { line: 7, vars: { i: (s) => s.vars.i + 1 }, exp: 'i 自增为 2。' }, { line: 12, vars: { k: (s) => s.vars.k + 1 }, exp: 'k 自增为 2。' }, { line: 4, exp: '再次循环。检查条件: i(2)<5 && j(0)<3 && k(2)<5，结果为真。' }, { line: 5, exp: '比较 first[2](3) 与 second[0](2)。' }, { line: 9, mem: { result: (s) => { s.mem.result[s.vars.k] = s.mem.second[s.vars.j]; return s.mem.result; } }, exp: '3 <= 2 为假。进入else分支。result[2] 被赋值为 second[0] 的值 2。' }, { line: 10, vars: { j: (s) => s.vars.j + 1 }, exp: 'j 自增为 1。' }, { line: 12, vars: { k: (s) => s.vars.k + 1 }, exp: 'k 自增为 3。' }, { line: 4, exp: '再次循环。检查条件: i(2)<5 && j(1)<3 && k(3)<5，结果为真。' }, { line: 5, exp: '比较 first[2](3) 与 second[1](2)。' }, { line: 9, mem: { result: (s) => { s.mem.result[s.vars.k] = s.mem.second[s.vars.j]; return s.mem.result; } }, exp: '3 <= 2 为假。result[3] 被赋值为 second[1] 的值 2。' }, { line: 10, vars: { j: (s) => s.vars.j + 1 }, exp: 'j 自增为 2。' }, { line: 12, vars: { k: (s) => s.vars.k + 1 }, exp: 'k 自增为 4。' }, { line: 4, exp: '再次循环。检查条件: i(2)<5 && j(2)<3 && k(4)<5，结果为真。' }, { line: 5, exp: '比较 first[2](3) 与 second[2](3)。' }, { line: 6, mem: { result: (s) => { s.mem.result[s.vars.k] = s.mem.first[s.vars.i]; return s.mem.result; } }, exp: '3 <= 3 为真。result[4] 被赋值为 first[2] 的值 3。' }, { line: 7, vars: { i: (s) => s.vars.i + 1 }, exp: 'i 自增为 3。' }, { line: 12, vars: { k: (s) => s.vars.k + 1 }, exp: 'k 自增为 5。' }, { line: 4, exp: '再次循环。检查条件: k(5)<5 为假。循环终止。' }, { line: 14, exp: '后续的循环由于 k 已达到5，条件不满足，将被跳过。程序执行结束。' } ]
        },
        {
            title: 'Q3: student_data', type: 'code_with_quiz',
            code: 'struct student_data\n{\n    std::string name;\n    int id;\n    int score;\n};',
            quiz: { question: "在 `struct student_data { ... };` 中, `struct` 关键字的核心作用是什么?", options: ["创建一个函数", "声明一个新变量", "定义一个新的自定义数据类型", "包含一个头文件"], answer: 2, explanation: "`struct` 用于定义一个新的数据类型“蓝图”，它能将不同类型的数据（如string, int）打包成一个有意义的整体。" }
        },
        {
            title: 'Q4: student_collection', type: 'code_with_quiz',
            code: 'const int MAX_STUDENTS = 100;\n\nstruct student_collection\n{\n    student_data students[MAX_STUDENTS];\n    int count = 0;\n};',
            quiz: { question: "在 `student_collection` 结构体中，`int count` 成员的关键用途是什么？", options: ["记录学生总数上限", "记录数组中当前已存储的学生数量", "计算学生的平均分", "存储学生的ID"], answer: 1, explanation: "`count` 是一个追踪器，它告诉我们数组的前多少个位置已经被有效的学生数据占据，这对于遍历和添加新学生至关重要。" }
        },
        {
            title: 'Q5: print_student', type: 'code_with_quiz',
            code: 'void print_student(const student_data &student)\n{\n    std::cout << student.name << " (" << student.id << ") " << student.score;\n\n    if (student.score >= 80)\n    {\n        std::cout << " congratulations";\n    }\n    std::cout << std::endl;\n}',
            quiz: { question: "为什么 `print_student` 的参数要声明为 `const student_data &student`？", options: ["为了让函数可以修改学生数据", "这只是个人编码风格，没有特殊含义", "为了提高效率并保证数据安全", "因为 C++ 规定必须这样做"], answer: 2, explanation: "`&` (引用) 避免了复制整个结构体，提高了效率。`const` (常量) 保证了函数不会意外修改传入的学生数据，增强了代码的安全性。这是 C++ 的一个重要最佳实践。" }
        },
        {
            title: 'Q6: read_student', type: 'code_with_quiz',
            code: 'student_data read_student()\n{\n    student_data result;\n    result.id = read_integer("Enter ID: ");\n    result.name = read_string("Enter Name: ");\n    \n    do {\n        result.score = read_integer("Enter Score: ");\n    } while (result.score < 0 || result.score > 100);\n\n    return result;\n}',
            quiz: { question: "使用 `do-while` 循环验证分数（0-100）的主要优点是什么？", options: ["代码更短", "循环保证至少执行一次，符合“先输入，后判断”的逻辑", "比 `while` 循环运行得更快", "可以处理非整数输入"], answer: 1, explanation: "`do-while` 循环先执行循环体再判断条件，非常适合需要先获取用户输入再进行验证的场景。" }
        },
        {
            title: 'Q7: calculate_average', type: 'code_with_quiz',
            code: 'double calculate_average_score(const student_collection &collection)\n{\n    if (collection.count == 0) return 0.0;\n\n    double total_score = 0.0;\n    for (int i = 0; i < collection.count; i++)\n    {\n        total_score += collection.students[i].score;\n    }\n    return total_score / collection.count;\n}',
            quiz: { question: "如果 `total_score` 被声明为 `int` 而不是 `double`，可能会发生什么问题？", options: ["程序会崩溃", "计算结果会失去小数部分，导致精度错误", "编译无法通过", "没有任何问题"], answer: 1, explanation: "在 C++ 中，两个整数相除的结果仍然是整数，小数部分会被直接截断。例如，`69 / 2` 的结果是 `34` 而不是 `34.5`。使用 `double` 可以确保进行浮点数除法，保留精度。" }
        },
        {
            title: 'Q8: add_student', type: 'code_with_quiz',
            code: 'void add_student(student_collection &collection, const student_data &new_student)\n{\n    if (collection.count < MAX_STUDENTS)\n    {\n        collection.students[collection.count] = new_student;\n        collection.count++;\n    }\n}',
            quiz: { question: "在 `add_student` 过程中，为什么 `student_collection` 参数必须是引用 (`&`)？", options: ["为了让代码看起来更专业", "为了防止 `collection` 被意外修改", "为了让函数能够直接修改原始的集合对象，而不是它的副本", "为了节省内存"], answer: 2, explanation: "如果去掉 `&`，函数将操作 `collection` 的一个副本。对副本的任何修改（如增加 `count`）都不会影响到 `main` 函数中的原始 `my_students` 对象。引用传递是修改函数外部变量的正确方式。" }
        },
        {
            title: 'Q9: Main函数执行', type: 'simulator',
            code: [ 'int main() {', '  student_collection my_students;', '  // 模拟第一次循环 (输入: "Fred", 2, 52)', '  student_data s1 = { "Fred", 2, 52 };', '  add_student(my_students, s1);', '  // 模拟第二次循环 (输入: "Wilma", 5, 85)', '  student_data s2 = { "Wilma", 5, 85 };', '  add_student(my_students, s2);', '  // 循环结束', '  // ... 打印和计算平均分', '}' ],
            steps: [ { line: 0, exp: '进入 main 函数。' }, { line: 1, vars: { 'my_students.count': 0 }, mem: { 'my_students.students': [] }, exp: '声明 `student_collection` 变量 `my_students`。count 初始化为 0。' }, { line: 3, vars: { 's1.name': '"Fred"', 's1.id': 2, 's1.score': 52 }, exp: '模拟第一次循环，调用 `read_student()` 得到学生 s1。' }, { line: 4, vars: { 'my_students.count': 1 }, mem: { 'my_students.students': (s) => { s.mem['my_students.students'].push({ name: "Fred", id: 2, score: 52 }); return s.mem['my_students.students']; } }, exp: '调用 `add_student()`。s1被添加到 my_students 数组中，count 增为 1。' }, { line: 6, vars: { 's2.name': '"Wilma"', 's2.id': 5, 's2.score': 85 }, exp: '模拟第二次循环，调用 `read_student()` 得到学生 s2。' }, { line: 7, vars: { 'my_students.count': 2 }, mem: { 'my_students.students': (s) => { s.mem['my_students.students'].push({ name: "Wilma", id: 5, score: 85 }); return s.mem['my_students.students']; } }, exp: '调用 `add_student()`。s2被添加到 my_students 数组中，count 增为 2。' }, { line: 8, exp: '模拟输入 "N"，while 循环结束。' }, { line: 9, vars: { 'average': 68.5 }, exp: '程序继续执行打印和计算平均分的操作。最终平均分为 (52+85)/2 = 68.5。' }, { line: 10, exp: '程序执行结束。' } ]
        }
    ];

    const tabsContainer = document.getElementById('question-tabs');
    const contentContainer = document.getElementById('content-container');
    let activeController = null;

    class Simulator {
        // ... (same as previous version, slightly adapted)
        constructor(question, container) { this.question = question; this.container = container; this.init(); }
        init() {
            this.container.innerHTML = `<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-6">
                <div class="panel font-mono lg:col-span-3"><div id="code-display"></div><div id="explanation" class="mt-4 bg-indigo-50 border-l-4 border-indigo-500 text-indigo-800 p-3 rounded-r-md"></div></div>
                <div class="panel font-mono lg:col-span-2"><div id="vars-display"></div><div id="mem-display" class="mt-6"></div></div>
            </div>
            <div class="panel flex justify-between items-center mt-4"><button id="reset-btn" class="btn btn-secondary"><i class="fas fa-undo"></i> 重置</button><div class="font-mono text-gray-600">步骤: <span id="step-counter">0</span> / ${this.question.steps.length}</div><button id="next-btn" class="btn btn-primary">下一步 <i class="fas fa-arrow-right"></i></button></div>`;
            Object.assign(this, { codeDisplay: this.container.querySelector('#code-display'), varsDisplay: this.container.querySelector('#vars-display'), memDisplay: this.container.querySelector('#mem-display'), explanation: this.container.querySelector('#explanation'), stepCounter: this.container.querySelector('#step-counter'), nextBtn: this.container.querySelector('#next-btn'), resetBtn: this.container.querySelector('#reset-btn') });
            this.nextBtn.addEventListener('click', () => this.next()); this.resetBtn.addEventListener('click', () => this.reset()); this.reset();
        }
        reset() { this.state = { step: 0, vars: {}, mem: {} }; this.lastChanged = { vars: [], mem: [] }; this.explanation.textContent = '请点击“下一步”开始执行。'; this.nextBtn.disabled = false; this.render(); }
        next() {
            if (this.state.step >= this.question.steps.length) return;
            const stepData = this.question.steps[this.state.step]; this.lastChanged = { vars: [], mem: [] };
            if (stepData.vars) for (const k in stepData.vars) { this.state.vars[k] = typeof stepData.vars[k] === 'function' ? stepData.vars[k](this.state) : stepData.vars[k]; this.lastChanged.vars.push(k); }
            if (stepData.mem) for (const k in stepData.mem) { this.state.mem[k] = typeof stepData.mem[k] === 'function' ? stepData.mem[k](this.state) : stepData.mem[k]; this.lastChanged.mem.push(k); }
            this.state.step++; this.render();
        }
        render() {
            const stepData = this.state.step > 0 ? this.question.steps[this.state.step - 1] : null;
            this.codeDisplay.innerHTML = this.question.code.map((l, i) => `<div class="code-line ${stepData && i === stepData.line ? 'active' : ''}">${l.replace(/</g, "&lt;")}</div>`).join('');
            let varsHTML = '<h3><i class="fas fa-microchip mr-2"></i>变量</h3>'; Object.keys(this.state.vars).forEach(k => { varsHTML += `<div class="flex justify-between p-2 rounded ${this.lastChanged.vars.includes(k) ? 'value-changed' : ''}"><span class="text-gray-600">${k}</span> <span class="text-blue-700 font-bold">${this.state.vars[k]}</span></div>`; }); this.varsDisplay.innerHTML = varsHTML;
            let memHTML = '<h3 class="mt-6"><i class="fas fa-memory mr-2"></i>内存 (数组)</h3>'; Object.keys(this.state.mem).forEach(k => { const val = this.state.mem[k]; let fVal = Array.isArray(val) ? `[ ${val.map(v => JSON.stringify(v).replace(/"/g, ' ')).join(', ')} ]` : JSON.stringify(val); memHTML += `<div class="flex justify-between p-2 rounded ${this.lastChanged.mem.includes(k) ? 'value-changed' : ''}"><span class="text-gray-600">${k}</span> <span class="text-blue-700 font-bold">${fVal}</span></div>`; }); this.memDisplay.innerHTML = memHTML;
            if(stepData) this.explanation.textContent = stepData.exp;
            this.stepCounter.textContent = this.state.step;
            if (this.state.step >= this.question.steps.length) this.nextBtn.disabled = true;
        }
    }

    class Quiz {
        constructor(question, container) {
            this.questionData = question;
            this.container = container;
            this.currentQ = 0;
            this.init();
        }
        init() { this.render(); }
        render() {
            const q = this.questionData.quizQuestions[this.currentQ];
            let codeHTML = this.questionData.code ? `<div class="panel font-mono mb-4"><div class="code-line">${this.questionData.code.replace(/\n/g, '<br>')}</div></div>` : '';
            this.container.innerHTML = `${codeHTML}
                <div class="panel">
                    <div class="mb-4">
                        <p class="text-lg font-semibold text-gray-800">${this.currentQ + 1}. ${q.question}</p>
                    </div>
                    <div id="quiz-options"></div>
                    <div id="quiz-feedback" class="mt-4 p-3 rounded-md text-sm" style="display: none;"></div>
                    <div class="flex justify-between mt-4">
                        <div class="text-gray-600">问题 ${this.currentQ + 1} / ${this.questionData.quizQuestions.length}</div>
                        <button id="next-quiz-btn" class="btn btn-primary" style="display:none;">下一个问题</button>
                    </div>
                </div>`;
            const optionsContainer = this.container.querySelector('#quiz-options');
            q.options.forEach((opt, index) => {
                const button = document.createElement('button');
                button.className = 'quiz-option';
                button.textContent = opt;
                button.onclick = () => this.checkAnswer(index);
                optionsContainer.appendChild(button);
            });
            this.container.querySelector('#next-quiz-btn').onclick = () => {
                this.currentQ++; this.render();
            };
        }
        checkAnswer(selectedIndex) {
            const q = this.questionData.quizQuestions[this.currentQ];
            const feedbackEl = this.container.querySelector('#quiz-feedback');
            const options = this.container.querySelectorAll('.quiz-option');
            options.forEach(o => o.disabled = true);
            if (selectedIndex === q.answer) {
                options[selectedIndex].classList.add('correct');
                feedbackEl.className = 'mt-4 p-3 rounded-md text-sm bg-green-100 border border-green-300 text-green-800';
            } else {
                options[selectedIndex].classList.add('incorrect');
                options[q.answer].classList.add('correct');
                feedbackEl.className = 'mt-4 p-3 rounded-md text-sm bg-red-100 border border-red-300 text-red-800';
            }
            feedbackEl.textContent = q.explanation;
            feedbackEl.style.display = 'block';
            if (this.currentQ < this.questionData.quizQuestions.length - 1) {
                this.container.querySelector('#next-quiz-btn').style.display = 'inline-flex';
            }
        }
    }

    function setActiveTab(index) {
        document.querySelectorAll('.tab').forEach((tab, i) => tab.classList.toggle('active', i === index));
        const question = questions[index];
        contentContainer.innerHTML = '';
        if (question.type === 'simulator') {
            activeController = new Simulator(question, contentContainer);
        } else if (question.type === 'quiz' || question.type === 'code_with_quiz') {
            activeController = new Quiz({ ...question, code: question.code, quizQuestions: question.quizQuestions || [question.quiz] }, contentContainer);
        }
    }
    
    questions.forEach((q, index) => {
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = q.title;
        tab.addEventListener('click', () => setActiveTab(index));
        tabsContainer.appendChild(tab);
    });
    
    setActiveTab(0);
    </script>
</body>
</html>

